<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cakephp | Daves dev warblings]]></title>
  <link href="http://jedistirfry.co.uk/blog/categories/cakephp/atom.xml" rel="self"/>
  <link href="http://jedistirfry.co.uk/"/>
  <updated>2015-08-04T15:56:04+01:00</updated>
  <id>http://jedistirfry.co.uk/</id>
  <author>
    <name><![CDATA[David Yell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to configure flash messages using Crud plugin]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-07/how-to-configure-flash-messages-using-crud-plugin/"/>
    <updated>2015-07-21T21:33:09+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-07/how-to-configure-flash-messages-using-crud-plugin</id>
    <content type="html"><![CDATA[<h2>Scenario</h2>

<p>You&rsquo;re using the <a href="https://github.com/friendsofcake/crud">Crud</a> plugin you might find that it will use the default flash message elements, so if, like me, you want to use something like <a href="http://getbootstrap.com/components/#alerts">Twitter Boostrap Alerts</a>, you&rsquo;re out of luck.</p>

<p>Never fear, help is at hand.</p>

<h2>Customise flash</h2>

<p>```php
// src/Controller/AppController.php
public function beforeFilter(Event $event)
{</p>

<pre><code>$this-&gt;eventManager()-&gt;on('Crud.beforeHandle', function () {
    $this-&gt;Crud-&gt;action()-&gt;config('messages.success', ['params' =&gt; ['class' =&gt; 'alert alert-success alert-dismissible']]);
    $this-&gt;Crud-&gt;action()-&gt;config('messages.error', ['params' =&gt; ['class' =&gt; 'alert alert-danger alert-dismissible']]);
});
</code></pre>

<p>}
```</p>

<p>I tend to put this, as per the example, in my <code>AppController</code> because that way it will only configure the messages for any action which will be handled by the Crud plugin, but across all my controllers.</p>

<h2>Success!</h2>

<p>That&rsquo;s it! Go make a brew.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding neighbours in CakePHP3]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-07/finding-neighbours-in-cakephp3/"/>
    <updated>2015-07-21T20:37:00+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-07/finding-neighbours-in-cakephp3</id>
    <content type="html"><![CDATA[<p>So it seems that in Cake 3 you can no longer use the <code>find('neighbors')</code> to find posts which are next to each other according to a defined series.</p>

<p>As I tend to use this for previous and next blog posts when viewing a blog post, I&rsquo;ll note down my technique here for future reference.</p>

<h2>The method</h2>

<p>```php
// src/Model/Table/ExamplesTable.php
/<em>*
 * Find an item from a table by slug, along with it&rsquo;s two adjacent items
 *
 * @param string $slug
 * @return array
 </em>/
public function neighbours($slug)
{</p>

<pre><code>$current = $this-&gt;find()
    -&gt;where(['slug' =&gt; $slug])
    -&gt;first();

$previous = $this-&gt;find()
    -&gt;where(['publish_date &lt;' =&gt; $current-&gt;publish_date-&gt;format('Y-m-d')])
    -&gt;order(['publish_date' =&gt; 'DESC'])
    -&gt;first();

$next = $this-&gt;find()
    -&gt;where(['publish_date &gt;' =&gt; $current-&gt;publish_date-&gt;format('Y-m-d')])
    -&gt;order(['publish_date' =&gt; 'DESC'])
    -&gt;first();

return [
    'current' =&gt; $current,
    'previous' =&gt; $previous,
    'next' =&gt; $next
];
</code></pre>

<p>}
```</p>

<h2>The finder</h2>

<p>I&rsquo;ve not been able to develop a finder for this as a custom find only gets passed a single query object and in order to do a Union between the previous and next you&rsquo;d need to join two query objects.</p>

<p>There is also the fact that you need to execute the query to return the result of the parent item so that its value can be passed to the query to find the siblings.</p>

<p>If you have any ideas on how to tackle this challenge, please let me know in the comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paginating multiple types of list in the same controller]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-04/paginating-multiple-types-of-list-in-the-same-controller/"/>
    <updated>2015-04-29T11:57:10+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-04/paginating-multiple-types-of-list-in-the-same-controller</id>
    <content type="html"><![CDATA[<h2>What a complicated title</h2>

<p>Okay, agreed. Perhaps an example would be better. Imagine you have a <code>ContentsController</code> which you use in your application to render lots of different types of content. You might have <code>ContentTypes</code> such as News, Guides, Articles, Pages, etc. so there is no point creating lots of controllers, when your <code>ContentsController::index()</code> method could just output the same thing with just different data.</p>

<p>This post is about how you deal with those lists in your routing and how to paginate them so that you can preserve your urls.</p>

<h2>Routing</h2>

<p>So the first thing to do is to setup your routing so that you can keep your content separate.</p>

<p>```php
Router::scope(&lsquo;/&rsquo;, function ($routes) {</p>

<pre><code>$routes-&gt;connect('/guides/:slug', ['controller' =&gt; 'Contents', 'action' =&gt; 'view', 'type' =&gt; 'Guides'], ['slug' =&gt; '[a-z-]+', 'pass' =&gt; ['type', 'slug']]);
$routes-&gt;connect('/guides', ['controller' =&gt; 'Contents', 'action' =&gt; 'index', 'type' =&gt; 'Guides'], ['pass' =&gt; ['type']]);

$routes-&gt;connect('/news/:slug', ['controller' =&gt; 'Contents', 'action' =&gt; 'view', 'type' =&gt; 'News'], ['slug' =&gt; '[a-z-]+', 'pass' =&gt; ['type', 'slug']]);
$routes-&gt;connect('/news', ['controller' =&gt; 'Contents', 'action' =&gt; 'index', 'type' =&gt; 'News'], ['pass' =&gt; ['type']]);
</code></pre>

<p>});
```</p>

<p>This now means that we can access all our different types of content on different urls so that it makes sense to the user.</p>

<h2>Creating our links</h2>

<p>So now we need to point users to our content.</p>

<p>```php
// Link to the index
echo $this->Html->link(&lsquo;Guides&rsquo;, [&lsquo;controller&rsquo; => &lsquo;Contents&rsquo;, &lsquo;action&rsquo; => &lsquo;index&rsquo;, &lsquo;type&rsquo; => &lsquo;Guides&rsquo;]);</p>

<p>// Link to a single item
echo $this->Html->link($guide->title, [&lsquo;controller&rsquo; => &lsquo;Contents&rsquo;, &lsquo;action&rsquo; => &lsquo;view&rsquo;, &lsquo;type&rsquo; => &lsquo;Guides&rsquo;, &lsquo;slug&rsquo; => $guide->slug]);
```</p>

<h2> Paginating the index</h2>

<p>As we are using a single view to paginate many different lists we need to tell the Pagination helper how to form the url properly.</p>

<p>```php
$this->Paginator->options([</p>

<pre><code>'url' =&gt; ['controller' =&gt; 'Contents', 'action' =&gt; 'index', 'type' =&gt; $type-&gt;name]
</code></pre>

<p>]);
```</p>

<p>This will now pass the <code>type</code> correctly in all our pagination links, which means that it&rsquo;ll match the routing correctly and you should end up with nicely paginated urls which match your routing such as <code>/guides?page=2</code>.</p>

<h2>Getting the list</h2>

<p>So you&rsquo;ll need to process the <code>type</code> when it&rsquo;s passed to your controller, so be sure to include it in your controllers method signature.</p>

<p>```php
class ContentsController extends AppController {</p>

<pre><code>public function index($type)
{
    // Lookup the data by type
    // Perhaps with a custom finder
}
</code></pre>

<p>}
```</p>

<h2>Make a brew</h2>

<p>It really is that simple!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Working with the Crud plugin in CakePHP]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-02/working-with-crud/"/>
    <updated>2015-02-13T12:31:00+00:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-02/working-with-crud</id>
    <content type="html"><![CDATA[<h2>So what is it?</h2>

<p>It&rsquo;s a plugin for CakePHP 2 and CakePHP 3 which saves you time and energy by automating basic tasks which you would usually write or bake youself. These are the CRUD operations (Create, Read, Update and Delete), hence the name of the plugin.</p>

<p>The idea is that instead of writing repeated controller actions the same functionality can be provided for any model automatically using the events system.</p>

<p>This post is about Crud v3 which is for Cake 2.x</p>

<p><a href="https://github.com/FriendsOfCake/crud">Read more about the plugin in the repo</a>.</p>

<h2>I&rsquo;m sold, how do I use it?</h2>

<p>Once the plugin is installed all you have to do is map a controller action to a crud action, create a controller and a view and you&rsquo;re job done. It&rsquo;s really that simple.</p>

<p>Let&rsquo;s do an example. I will add comments to the code for various techniques.</p>

<p><strong>Assumptions</strong><br/>
Here we&rsquo;ll assume the plugin is loaded already, the trait is being used and we have a model called <code>Examples</code>.
The following example is for Cake 2, as in Cake 3, there is no need to use the <code>prefix_method</code> notation.</p>

<p>```php
// I tend to configure Crud in my AppController to save on repitition
class AppController extends Controller {</p>

<pre><code>use CrudControllerTrait;

public $components = [
    // Here we can configure our action maps, finders and all kinds of things
    'Crud.Crud' =&gt; [
        'actions' =&gt; [
            'index' =&gt; 'Crud.index', // Map any index action to the Crud index action handler
            'view' =&gt; [
                // Configure the options for this action method
                'className' =&gt; 'Crud.view',
                'validateId' =&gt; false
            ],
            'admin_index' =&gt; 'Crud.index', // We can even hookup prefix methods
            'admin_add' =&gt; 'Crud.add',
            'admin_edit' =&gt; 'Crud.edit',
            'admin_delete' =&gt; 'Crud.delete'
        ]
    ]
];
</code></pre>

<p>}</p>

<p>// Create your ExamplesController.php
class ExamplesController extends AppController {</p>

<pre><code>// We don't need any code here because Crud plugin can handle the methods for us!

// If we want to just change how this action finds it's data we can specify a custom 
// finder method and still have Crud do the rest of the work for us
public function view($slug) {
    $this-&gt;Crud-&gt;action()-&gt;findMethod('slug');
    return $this-&gt;Crud-&gt;execute();
}

// What if we want to change the pagination in the index action?
public function index() {
    // We can hook the beforePaginate event to make changes
    $this-&gt;Crud-&gt;on('beforePaginate', function (CakeEvent $event) {
        // The event subject here is the controller, and paginator is the 
        // paginator component.
        // So we can change the page limit to 10 to include 10 items per page
        // and we could contain a related model too!
        $event-&gt;subject()-&gt;paginator-&gt;settings = [
            'contain' =&gt; [
                'User'
            ],
            'limit' =&gt; 10
        ];
    });

    // Let crud handle the rest of the action
    return $this-&gt;Crud-&gt;execute();
}
</code></pre>

<p>}</p>

<p>// Create our view Examples/index.ctp</p>

<div class='examples index'>
    <?php foreach($examples as $example) {
        echo $example['Example']['title'];
    }?>
</div>


<p>```</p>

<h2> Woah, we just did loads!</h2>

<p>Yep, with the above example, we&rsquo;ve created all our admin prefixed Example methods, both our index and view methods. It&rsquo;s amazing how much quicker you can do stuff when you focus on the parts of your system which are not in the basic four CRUD actions.</p>

<h2>Make a brew</h2>

<p>Why not eh? You&rsquo;ve got loads of spare time now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting multi-dimension model data]]></title>
    <link href="http://jedistirfry.co.uk/blog/2014-08/sorting-data/"/>
    <updated>2014-08-12T15:42:10+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2014-08/sorting-data</id>
    <content type="html"><![CDATA[<h3>Scenario</h3>

<p>So often you have a large collection of collated data, probably with some calculated fields and you want to sort one of the dimensions by a certain value. Pretty hard using regular array methods, unless you start slicing arrays out of their dimension, sort them and inject them back in. We don&rsquo;t want to do that because it&rsquo;s fiddly.</p>

<h3>Solution</h3>

<p>So the solution I like to use is to use <a href="http://php.net/manual/en/function.usort.php">usort()</a>. Which is a handy function allowing you to sort an array using your own function. Perfect if you want to sort a related models data.</p>

<h3>Example</h3>

<p>So for the example we&rsquo;ll assume that we have a <code>League</code> model which <code>hasMany</code> <code>LeaguesUser</code>. We want to count the number of points a user has and order the data accordingly.</p>

<p>When returned from a Cake <code>find()</code> we&rsquo;ll end up with related data in dimensions.
```php
&lt;?php
array (size=2)
  &lsquo;League&rsquo; =></p>

<pre><code>array (size=9)
  'id' =&gt; string '1' (length=1)
  'name' =&gt; string 'Examples!' (length=9)
  'slug' =&gt; string 'examples' (length=9)
  'description' =&gt; string 'The league for people who like examples' (length=45)
  'cover' =&gt; string '1000x1000.jpg' (length=13)
  'image_dir' =&gt; string '1' (length=1)
  'join_code' =&gt; string 'da39a3ee5e6b4b0d3255bfef95601890afd80709' (length=40)
  'created' =&gt; string '2014-08-04 10:45:45' (length=19)
  'modified' =&gt; string '2014-08-11 14:54:34' (length=19)
</code></pre>

<p>  &lsquo;LeaguesUser&rsquo; =></p>

<pre><code>array (size=2)
  0 =&gt; 
    array (size=5)
      'id' =&gt; string '1' (length=1)
      'league_id' =&gt; string '1' (length=1)
      'user_id' =&gt; string '2' (length=1)
      'admin' =&gt; boolean true
      'User' =&gt; 
        array (size=5)
          'id' =&gt; string '2' (length=1)
          'email' =&gt; string 'test@example.com' (length=16)
          'username' =&gt; string 'testuser' (length=8)
          'predictions' =&gt; int 2
          'correct' =&gt; int 0
  1 =&gt; 
    array (size=5)
      'id' =&gt; string '2' (length=1)
      'league_id' =&gt; string '1' (length=1)
      'user_id' =&gt; string '1' (length=1)
      'admin' =&gt; boolean false
      'User' =&gt; 
        array (size=5)
          'id' =&gt; string '1' (length=1)
          'email' =&gt; string 'testuser1@example.com' (length=20)
          'username' =&gt; string 'testuser1' (length=8)
          'predictions' =&gt; int 2
          'correct' =&gt; int 1
</code></pre>

<p>```</p>

<p>So let&rsquo;s sort that <code>LeaguesUser['User']</code> dimension by the number of correct predicitons.</p>

<p>Firstly, we&rsquo;ll want to create a new <code>private function sortByCorrect($a, $b)</code> in our controller. Then we just need to sort using it in our currenct controller method.</p>

<p>The important thing to note is that the callable function passed to <code>usort()</code> is an array containing the current controller as the first item. <code>usort($data, [$this, 'callableFunction'])</code> without including <code>$this</code> you&rsquo;ll get an error.</p>

<p>```php
&lt;?php
public function view($slug) {</p>

<pre><code>$league = $this-&gt;League-&gt;find('first', [
    'contain' =&gt; [
        'LeaguesUser' =&gt; [
            'User' =&gt; [
                'fields' =&gt; ['id', 'email', 'username', 'correct', 'predicitons']
            ]
        ]
    ],
    'conditions' =&gt; [
        'League.slug' =&gt; $slug
    ]
]);

usort($league, [$this, 'sortByCorrect']);

$this-&gt;set('league', $league);
</code></pre>

<p>}</p>

<p>private function sortByCorrect($a, $b) {</p>

<pre><code>if ($a['User']['correct'] &lt; $b['User']['correct']) {
    return 1;
} elseif ($a['User']['correct'] == $b['User']['correct']) {
    return 0;
} else {
    return -1;
}
</code></pre>

<p>}</p>

<p>// Rest of controller
```</p>

<h3>Done</h3>

<p>Go make a brew! Your work here is done.</p>
]]></content>
  </entry>
  
</feed>
