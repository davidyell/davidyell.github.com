<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cakephp3 | Daves dev warblings]]></title>
  <link href="http://jedistirfry.co.uk/blog/categories/cakephp3/atom.xml" rel="self"/>
  <link href="http://jedistirfry.co.uk/"/>
  <updated>2015-09-11T12:41:11+01:00</updated>
  <id>http://jedistirfry.co.uk/</id>
  <author>
    <name><![CDATA[David Yell]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Connecting to a remote web service]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-09/connecting-to-a-web-service/"/>
    <updated>2015-09-11T12:21:14+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-09/connecting-to-a-web-service</id>
    <content type="html"><![CDATA[<h2>First things first</h2>

<p>So the first thing you&rsquo;ll need is the <a href="https://github.com/UseMuffin/Webservice">Webservice plugin</a>.</p>

<p><code>bash
composer require muffin/webservice:dev-master &amp;&amp; bin/cake plugin load Muffin/Webservice
</code></p>

<p>Then be sure to add the configuration for your service to the <code>config/app.php</code> file.
This means you need to add another array key to your config, it should contain something like the following.</p>

<p>```php
&lsquo;Webservices&rsquo; => [</p>

<pre><code>'Twitter' =&gt; [
    'className' =&gt; 'Muffin\Webservice\Connection',
    'service' =&gt; 'App\Lib\Twitter\Driver\Twitter',
    'username' =&gt; $_ENV['GITHUB_USERNAME'],
    'password' =&gt; $_ENV['GITHUB_PASSWORD'],
]
</code></pre>

<p>]
```</p>

<p>I&rsquo;ll talk through the various config options here.</p>

<h3>className</h3>

<p>This is a proxy class which will pass method calls through to your own driver class.</p>

<h3>service</h3>

<p>This is your driver class where you&rsquo;ll write your code and connect to the service.</p>

<h3>username/password</h3>

<p>Any login credentials you need will have to be included.</p>

<h2>Creating your driver class</h2>

<p>So you need to create a new driver class, which uses the Webservice plugin as a base.
For my example, I&rsquo;ve created my Twitter driver class in <code>src/Lib/Twitter/Driver/Twitter.php</code> which
extends <code>Muffin\Webservice\AbstractDriver</code>, and I&rsquo;ve implemented the stub method, which is just <code>initialize</code>,
to setup the client you want to use.</p>

<p>```php
// src/Lib/Twitter/Driver/Twitter.php
namespace App\Lib\Twitter\Driver;</p>

<p>use Cake\Network\Http\Client;
use Muffin\Webservice\AbstractDriver;</p>

<p>class Twitter extends AbstractDriver
{</p>

<pre><code>public function initialize()
{
    // Let's use the CakePHP Http client class
    $this-&gt;_client = new \Cake\Network\Http\Client();
}

// etc
</code></pre>

<p>```</p>

<p><strong>There is a gotcha here!</strong><br/>
You will need to implement some methods from <code>Cake\Database\Connection</code> into
your driver class so that DebugKit can interact with your driver. These methods
can be copied and pasted from the Connection class.</p>

<ul>
<li><code>configName()</code></li>
<li><code>logQueries()</code></li>
<li><code>logger()</code></li>
</ul>


<h2>Creating your method</h2>

<p>So assuming we want to get some tweets, we can create a method for that inside
our driver class.</p>

<p>```php</p>

<pre><code>public function tweets()
{
    // Do some setup for Twitter
    return $this-&gt;_client-&gt;post($url, $dataArray);
}
</code></pre>

<p>```
This will use the CakePHP Http Client to post to a Twitter url and return the response.</p>

<h2> Using your new driver</h2>

<p>So now we need to actually get the data to play with. In our controller we need to
instantiate the connection and call our new method.</p>

<p>```php
// ExamplesController.php</p>

<pre><code>public function getTweets()
{
    $connection = ConnectionManager::get('Twitter');
    $tweets = $connection-&gt;tweets();
    $this-&gt;set('tweets', $tweets);
}
</code></pre>

<p>```</p>

<p>You must make sure that the name of the connection you give to ConnectionManager matches
the name you used in your <code>app.php</code> config setup.</p>

<h2>That&rsquo;s it!</h2>

<p>Job done! Have a brew.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to configure flash messages using Crud plugin]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-07/how-to-configure-flash-messages-using-crud-plugin/"/>
    <updated>2015-07-21T21:33:09+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-07/how-to-configure-flash-messages-using-crud-plugin</id>
    <content type="html"><![CDATA[<h2>Scenario</h2>

<p>You&rsquo;re using the <a href="https://github.com/friendsofcake/crud">Crud</a> plugin you might find that it will use the default flash message elements, so if, like me, you want to use something like <a href="http://getbootstrap.com/components/#alerts">Twitter Boostrap Alerts</a>, you&rsquo;re out of luck.</p>

<p>Never fear, help is at hand.</p>

<h2>Customise flash</h2>

<p>```php
// src/Controller/AppController.php
public function beforeFilter(Event $event)
{</p>

<pre><code>$this-&gt;eventManager()-&gt;on('Crud.beforeHandle', function () {
    $this-&gt;Crud-&gt;action()-&gt;config('messages.success', ['params' =&gt; ['class' =&gt; 'alert alert-success alert-dismissible']]);
    $this-&gt;Crud-&gt;action()-&gt;config('messages.error', ['params' =&gt; ['class' =&gt; 'alert alert-danger alert-dismissible']]);
});
</code></pre>

<p>}
```</p>

<p>I tend to put this, as per the example, in my <code>AppController</code> because that way it will only configure the messages for any action which will be handled by the Crud plugin, but across all my controllers.</p>

<h2>Success!</h2>

<p>That&rsquo;s it! Go make a brew.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding neighbours in CakePHP3]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-07/finding-neighbours-in-cakephp3/"/>
    <updated>2015-07-21T20:37:00+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-07/finding-neighbours-in-cakephp3</id>
    <content type="html"><![CDATA[<p>So it seems that in Cake 3 you can no longer use the <code>find('neighbors')</code> to find posts which are next to each other according to a defined series.</p>

<p>As I tend to use this for previous and next blog posts when viewing a blog post, I&rsquo;ll note down my technique here for future reference.</p>

<h2>The method</h2>

<p>```php
// src/Model/Table/ExamplesTable.php
/<em>*
 * Find an item from a table by slug, along with it&rsquo;s two adjacent items
 *
 * @param string $slug
 * @return array
 </em>/
public function neighbours($slug)
{</p>

<pre><code>$current = $this-&gt;find()
    -&gt;where(['slug' =&gt; $slug])
    -&gt;first();

$previous = $this-&gt;find()
    -&gt;where(['publish_date &lt;' =&gt; $current-&gt;publish_date-&gt;format('Y-m-d')])
    -&gt;order(['publish_date' =&gt; 'DESC'])
    -&gt;first();

$next = $this-&gt;find()
    -&gt;where(['publish_date &gt;' =&gt; $current-&gt;publish_date-&gt;format('Y-m-d')])
    -&gt;order(['publish_date' =&gt; 'DESC'])
    -&gt;first();

return [
    'current' =&gt; $current,
    'previous' =&gt; $previous,
    'next' =&gt; $next
];
</code></pre>

<p>}
```</p>

<h2>The finder</h2>

<p>I&rsquo;ve not been able to develop a finder for this as a custom find only gets passed a single query object and in order to do a Union between the previous and next you&rsquo;d need to join two query objects.</p>

<p>There is also the fact that you need to execute the query to return the result of the parent item so that its value can be passed to the query to find the siblings.</p>

<p>If you have any ideas on how to tackle this challenge, please let me know in the comments.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paginating multiple types of list in the same controller]]></title>
    <link href="http://jedistirfry.co.uk/blog/2015-04/paginating-multiple-types-of-list-in-the-same-controller/"/>
    <updated>2015-04-29T11:57:10+01:00</updated>
    <id>http://jedistirfry.co.uk/blog/2015-04/paginating-multiple-types-of-list-in-the-same-controller</id>
    <content type="html"><![CDATA[<h2>What a complicated title</h2>

<p>Okay, agreed. Perhaps an example would be better. Imagine you have a <code>ContentsController</code> which you use in your application to render lots of different types of content. You might have <code>ContentTypes</code> such as News, Guides, Articles, Pages, etc. so there is no point creating lots of controllers, when your <code>ContentsController::index()</code> method could just output the same thing with just different data.</p>

<p>This post is about how you deal with those lists in your routing and how to paginate them so that you can preserve your urls.</p>

<h2>Routing</h2>

<p>So the first thing to do is to setup your routing so that you can keep your content separate.</p>

<p>```php
Router::scope(&lsquo;/&rsquo;, function ($routes) {</p>

<pre><code>$routes-&gt;connect('/guides/:slug', ['controller' =&gt; 'Contents', 'action' =&gt; 'view', 'type' =&gt; 'Guides'], ['slug' =&gt; '[a-z-]+', 'pass' =&gt; ['type', 'slug']]);
$routes-&gt;connect('/guides', ['controller' =&gt; 'Contents', 'action' =&gt; 'index', 'type' =&gt; 'Guides'], ['pass' =&gt; ['type']]);

$routes-&gt;connect('/news/:slug', ['controller' =&gt; 'Contents', 'action' =&gt; 'view', 'type' =&gt; 'News'], ['slug' =&gt; '[a-z-]+', 'pass' =&gt; ['type', 'slug']]);
$routes-&gt;connect('/news', ['controller' =&gt; 'Contents', 'action' =&gt; 'index', 'type' =&gt; 'News'], ['pass' =&gt; ['type']]);
</code></pre>

<p>});
```</p>

<p>This now means that we can access all our different types of content on different urls so that it makes sense to the user.</p>

<h2>Creating our links</h2>

<p>So now we need to point users to our content.</p>

<p>```php
// Link to the index
echo $this->Html->link(&lsquo;Guides&rsquo;, [&lsquo;controller&rsquo; => &lsquo;Contents&rsquo;, &lsquo;action&rsquo; => &lsquo;index&rsquo;, &lsquo;type&rsquo; => &lsquo;Guides&rsquo;]);</p>

<p>// Link to a single item
echo $this->Html->link($guide->title, [&lsquo;controller&rsquo; => &lsquo;Contents&rsquo;, &lsquo;action&rsquo; => &lsquo;view&rsquo;, &lsquo;type&rsquo; => &lsquo;Guides&rsquo;, &lsquo;slug&rsquo; => $guide->slug]);
```</p>

<h2> Paginating the index</h2>

<p>As we are using a single view to paginate many different lists we need to tell the Pagination helper how to form the url properly.</p>

<p>```php
$this->Paginator->options([</p>

<pre><code>'url' =&gt; ['controller' =&gt; 'Contents', 'action' =&gt; 'index', 'type' =&gt; $type-&gt;name]
</code></pre>

<p>]);
```</p>

<p>This will now pass the <code>type</code> correctly in all our pagination links, which means that it&rsquo;ll match the routing correctly and you should end up with nicely paginated urls which match your routing such as <code>/guides?page=2</code>.</p>

<h2>Getting the list</h2>

<p>So you&rsquo;ll need to process the <code>type</code> when it&rsquo;s passed to your controller, so be sure to include it in your controllers method signature.</p>

<p>```php
class ContentsController extends AppController {</p>

<pre><code>public function index($type)
{
    // Lookup the data by type
    // Perhaps with a custom finder
}
</code></pre>

<p>}
```</p>

<h2>Make a brew</h2>

<p>It really is that simple!</p>
]]></content>
  </entry>
  
</feed>
